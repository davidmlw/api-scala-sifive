#!/usr/bin/env python3

# Intended for use by wake to launch a bloop build server with a timeout

import os
import sys
import time
import subprocess
import common

if sys.version_info[0] < 3 or sys.version_info[1] < 5:
    print("This program requires Python version 3.5 or newer!")
    sys.exit(1)

my_dir = os.path.dirname(os.path.realpath(__file__))
my_name = os.path.basename(__file__)

def launch_timeout():
    cmd = [common.timeout_executable()]
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    # Wait until we get signal from subprocess that it has successfully written
    # the pid file. Child indicates it has done something by printing to stdout
    proc.stdout.read(1)

def is_bloop_running():
    proc = subprocess.run([common.bloop_executable(), "about"],
                          stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return proc.returncode == 0

# FIXME Can we verify that *we* successfully launched it?
# Maybe compare the PID of our launched daemon and the actual PID?
#  ^ This probably won't work because we're using blp-server
def launch_bloop():
    """
    Launches bloop and then waits until it is running
    """
    cmd = ["sh", common.bloop_launcher()] # FIXME why is "sh" necessary?
    # Use parent PATH and override TERM to suppress annoying
    #  "tput: No value for $TERM and no -T specified"
    env = { "PATH": os.environ["PATH"], "TERM": "dumb" }
    # TODO can we send stdout/err to /dev/null?
    proc = subprocess.Popen(cmd, stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL, env=env)
    while not is_bloop_running():
        # FIXME better wait amount?
        time.sleep(0.5)


# TODO Check this algorithm and if it's properly threadsafe
if __name__ == "__main__":
    bloop_timeout = "{}/bloop_timeout".format(my_dir)

    launched_timeout = False
    if os.path.isfile(common.pid_file()):
        launch_timeout()
        launched_timeout = True

    if is_bloop_running():
        print("[{}] Bloop is already running!".format(my_name))
        # Do we need to do this again?
        if not launched_timeout and os.path.isfile(common.pid_file()):
            launch_timeout()
            launched_timeout = True
    else:
        print("[{}] Launching Bloop!".format(my_name))
        launch_bloop()
        if not launched_timeout:
            launch_timeout()
            launched_timeout = True

    if launched_timeout:
        print("[{}] We are managing the bloop server".format(my_name))
