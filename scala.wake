
# Important directories
def root = mkdir 0775 ".scala-wake"
def bloopDir = mkdir 0775 ".bloop"

#global def coursierBin _ =
#  def version = "1.1.0-M11-2"
#  def dir = mkdir 0775 "{root.getPathName}/bin"
#  def getter = sources here 'getCoursier\.sh' | head
#  def cmd = getter.getPathName, dir.getPathName, version, Nil
#  def doit = job cmd (dir, getter, Nil)
#  doit.getJobOutput

# Should be installed by wake
global def coursierBin =
  def version = "1.1.0-M11-2"
  def bin = files "{root.getPathName}/bin" ".*coursier.*"
  bin | head | makeStatePath

global def ivyCache = mkdir 0775 "{root.getPathName}/cache"

global def millBin _ =
  def version = "0.3.5"
  def dir = mkdir 0775 "{root.getPathName}/bin"
  def getter = sources here 'getMill\.sh' | head
  def cmd = getter.getPathName, dir.getPathName, version, Nil
  def doit = job cmd (getter, dir, Nil)
  doit.getJobOutput

# TODO
# - Rename?
# Given List IvyDep, returns List String
# Return is paths to jars of the input IvyDeps and their transitive dependencies
global def coursierFetch deps =
  def depStrs = map ivyDepToCoursier deps
  def cachedDeps = files ivyCache.getPathName '.*' | map makeStatePath
  def cmd = coursierBin.getPathName, "fetch", "-q", "--cache", ivyCache.getPathName, "-m", "offline", depStrs
  def doit = job cmd (coursierBin, cachedDeps)
  if doit.getJobStatus == 0 then
    doit.getJobStdout | tokenize '\n' | filter ("{_}x" !=~ "x") # filter non-empty
  else raise "Cannot resolve ivy dependencies, have you run `wit update` (currently unimplemented)?"

# TODO Dotty support?
tuple ScalaVersion =
  global Major Integer
  global Minor Integer

def scalaVersionToString = match _
  ScalaVersion major minor = "2.{str(major)}.{str(minor)}"

global def makeScalaVersion str =
  def err = raise "Only Scala 2.X.Y accepted, got '{str}'"
  match (tokenize '\.' str)
    majormajor, major, minor, Nil =
      if majormajor ==~ "2" then ScalaVersion (int major) (int minor) else err
    _ = err

# TODO additional resolvers/repositories
tuple IvyDep =
  global Org String
  global Name String
  global Rev String

global def makeScalaIvyDep string scalaVersion =
  def err = raise "Malformed Scala Ivy Dep '{string}'"
  match (tokenize ':' string)
    org, name, rev, Nil = IvyDep org name rev
    org, blank, name, rev, Nil =
      def namex = "{name}_2.{str(scalaVersion.getScalaVersionMajor)}"
      if "{blank}x" ==~ "x" then IvyDep org namex rev else err
    _ = err

def ivyDepToCoursier = match _
  IvyDep org name rev = "{org}:{name}:{rev}"

global def scalaCompilerIvyDep version =
  IvyDep "org.scala-lang" "scala-compiler" (scalaVersionToString version)
global def scalaLibraryIvyDep version =
  IvyDep "org.scala-lang" "scala-library" (scalaVersionToString version)

tuple ScalaModule =
  global Name         String
  global RootDir      String
  global ScalaVersion ScalaVersion
  global IvyDeps      List IvyDep
  global Deps   List ScalaModule
  SourceDirs_         List String
  ResourceDirs        List String

global def getScalaModuleSourceDirs = match _
  ScalaModule _ dir _ _ _ sourceDirs _ =
    map ("{dir}/{_}") sourceDirs

# Should the source dirs be relative to root or incldue it?
global def makeSBTScalaModule name dir version =
  def scalaVersion = makeScalaVersion version
  def sourceDirs = "src/main/scala", "src/main/java", Nil | map ("{dir}/{_}")
  def resourceDirs = "{dir}/src/main/resources", Nil
  ScalaModule name dir scalaVersion Nil Nil sourceDirs resourceDirs

# TODO implement scalacOptions
global def bloopScalaLibJSON scalaVersion =
  def ivyDep = scalaCompilerIvyDep scalaVersion
  def org = Pair "organization" (JString ivyDep.getIvyDepOrg)
  def name = Pair "name" (JString ivyDep.getIvyDepName)
  def version = Pair "version" (JString ivyDep.getIvyDepRev)
  def options = Pair "options" (JArray Nil)
  def jars = Pair "jars" $ coursierFetch (ivyDep, Nil) | map JString | JArray
  def setup =
    def fields =
      Pair "order" (JString "mixed")
      , Pair "addLibraryToBootClasspath" (JBoolean True)
      , Pair "addCompilerToClasspath" (JBoolean False)
      , Pair "addExtraJarsToClasspath" (JBoolean False)
      , Pair "manageBootClasspath" (JBoolean True)
      , Pair "filterLibraryFromClasspath" (JBoolean True)
      , Nil
    Pair "setup" (JObject fields)
  JObject (org, name, version, options, jars, setup, Nil)

#def buildDir module = "{root.getPathName}/{module.getScalaModuleName}"
def bloopOutDir module = "{bloopDir.getPathName}/{module.getScalaModuleName}"
def bloopClassesDir module = "{root.getPathName}/{module.getScalaModuleName}/classes"

# TODO
# - implement module dependencies (see jdeps)
global def bloopScalaModuleJSON scalaModule =
  def bloopVersion = "1.2.5"
  def project = match scalaModule
    ScalaModule name dir version ivyDeps modDeps sourceDirs resourceDirs =
      def myDir = bloopOutDir scalaModule
      def scalaLib = scalaLibraryIvyDep version
      def fields =
        Pair   "name" (JString name)
        , Pair "directory" (JString dir)
        , Pair "sources" (JArray $ map (JString "{dir}/{_}") sourceDirs)
        , Pair "dependencies" (JArray Nil)
        , Pair "classpath" $ (scalaLib, ivyDeps) | coursierFetch | map JString | JArray
        , Pair "out" $ bloopOutDir scalaModule | JString
        , Pair "classesDir" $ bloopClassesDir scalaModule | JString
        , Pair "scala" (bloopScalaLibJSON version)
        , Nil
      #JObject (jname, jdir, jsources, jdeps, jcp, jout, jclasses, jscala, Nil)
      JObject fields
  def bloop = Pair "version" (JString bloopVersion)
  def proj = Pair "project" project
  JObject (bloop, proj, Nil)

global def bloopConfig module =
  def content = bloopScalaModuleJSON module | formatJSON
  write 0664 (bloopConfigName module) content

global def bloopConfigName module =
  def name = module.getScalaModuleName
  "{bloopDir.getPathName}/{name}.json"

# TODO Delete me
publish path = "/home/koenig/.bloop"

# TODO
# - Include Bloop configs and build dirs for dependencies
# - Use local bloop
# - Fix need for overriding outputs (why is it empty by default?)
global def compileScalaModule module =
  def config = module.bloopConfig
  def outdir = mkdir 0775 module.bloopClassesDir
  def statedir = makeStatePath module.bloopOutDir
  def sourceFiles =
    def dirs = module.getScalaModuleSourceDirs
    map (sources _ '.*\.(scala|java)') dirs | flatten
  def cmd = which "bloop", "run", module.getScalaModuleName, Nil
  def visible = (config, outdir, statedir, sourceFiles)
  def fnoutputs = match _
    Nil = files outdir.getPathName '.*\.class'
    other = raise "Outputs were non-empty as they should be! FIXME"
  def plan =
    #| setPlanFnOutputs fnoutputs
    makePlan cmd visible
  def job = plan.runJob
  def _ = format plan | println
  Pair (Pair job.getJobStdout job.getJobOutputs) job.getJobInputs

global def jack =
  def fields =
    Pair "name" (JString "Jack Koenig")
    , Pair "age"  (JInteger 27)
    , Pair "extra" (JArray (JString "one", JString "two", Nil))
    , Nil
  JObject fields #| prettyJSON

