
# Important directories
def buildRoot = mkdir "build"
def root = mkdir "{buildRoot.getPathName}/{here}"
def bloopDir = mkdir "{root.getPathName}/bloop"
# Where I expect Scala to be installed by wit
def bloopInstall = "scala"
# Where I expect Scala Ivy dependencies to be downloaded
def ivyCache = "ivycache"
# Python wrapper script for invoking bloop
def bloopWake = source "{here}/bloop_wake"

global def readIvyDepsJSON dir =
  source "{dir}/ivydependencies.json" | getPathName | parseJSONFile

# Should be installed by wit
def coursierBin =
  def bins = files bloopInstall '.*coursier.*'
  def bin = bins | head | makeStatePath
  try (\_ raise "Coursier not found! Did you run `wit fetch-scala`?") bin

# Virtual job that owns all fetched ivy dependencies
def ivyCacheDeps Unit =
  def fs = files ivyCache '.*'
  makePlan ("<ivycache>", ivyCache, Nil) Nil
  | setPlanKeep      False
  | setPlanFnOutputs (\_ fs)
  | runJobWith       virtualRunner
  | getJobOutputs

# Memoized tree for converting from Strings to Paths to jars in Coursier cache
def ivyCacheJars Unit = memoize 0 (
  def isJar = matches '.*\.jar' _.getPathName
  ivyCacheDeps Unit
  | filter isJar
  | map (\p Pair p.getPathName.stripIvyPathPrefix p)
  | listToTree cmpIvyCachePair
)

# TODO This is kind of sketchy, are releases and maven2 sufficient?
def stripIvyPathPrefix name =
  extract '.*?/(?:releases|maven2)/(.*)' name | head

def ivyDepToCoursierCache dep =
  match dep.requireExpanded
    IvyDep org name rev _ =
      def prefix = replace '\.' '/' org
      "{prefix}/{name}/{rev}/{name}-{rev}.jar"

def cmpIvyCachePair (Pair n1 _) (Pair n2 _) = n1 <=>* n2

def getIvyDepJars filenames =
  def dummyPath = bloopWake # A explicitly dummy path
  def pairs = map (Pair _ dummyPath) filenames
  def mtree = listToTree cmpIvyCachePair pairs
  (ivyCacheJars Unit) ∩ mtree | treeToList | map getPairSecond

# Get the Jar for an IvyDep
# Returns a Path
global def getIvyDepJar dep =
  def err Unit =
    raise "{dep.ivyDepToString} not found in downloaded ivy dependencies! Did you run `wit fetch-scala`?"
  match (getIvyDepJars (dep.requireExpanded.ivyDepToCoursierCache, Nil))
    value, Nil = value
    Nil        = err Unit
    _          = raise "This shouldn't be possible"

def requireExpanded dep =
  if dep.isIvyDepExpanded then dep else raise "Unexpanded IvyDep '{dep.ivyDepToString}'"

# TODO
# - Can we make this a fuse job? For some reason coursier can't find visible inputs
# Determines transitive ivy dependencies
# Given List IvyDep, returns List Path
# Returns paths to dep jars and transitive dependencies
global def resolveIvyDeps deps =
  def depStrs = map (_.requireExpanded.ivyDepToString) deps
  def cachedDeps = ivyCacheDeps Unit
  def cmd = coursierBin.getPathName, "fetch", "-q", "--cache", ivyCache, "-m", "offline", depStrs
  def plan = makeManualPlan cmd (coursierBin, cachedDeps) (\_ Nil)
  def job = plan.runJob # pointless
  def strs =
    if job.getJobStatus == 0
    then job.getJobStdout | tokenize '\n' | filter (_ !=* "")
    else raise "Cannot resolve ivy dependencies, have you run `wit fetch-scala`?"
  # Using the output of coursier, we get the actual paths and filter into requested and transitive
  def filenames = map stripIvyPathPrefix strs
  def res = getIvyDepJars filenames
  def err Unit =
    def fns = catWith ", " filenames
    def paths = res | map format | catWith ", "
    raise "Something went wrong! Looking for {fns}, got wrong number of paths: {paths}"
  if res.len != filenames.len then (err Unit) else res


# TODO improve
global def runIvyDep dep = resolveIvyDeps (dep, Nil) | runJava

# TODO improve
# - Customize java installation
# - Add Java options (eg. -Xmx4G)
# visible excludes classpath
global def runJava classpath main args visible =
  def java = which "java"
  def cp = map getPathName classpath | catWith ":"
  def cmd = java, "-cp", cp, main, args
  job cmd (visible ++ classpath)

# TODO Dotty support?
tuple ScalaVersion =
  global Major: Integer
  global Minor: Integer

global def scalaVersionToString (ScalaVersion major minor) =
  "2.{str major}.{str minor}"

global def scalaVersionMajorString (ScalaVersion major _) =
  "2.{str major}"

global def stringToScalaVersion str =
  match (tokenize '\.' str)
    "2", major, minor, Nil =
      (ScalaVersion _ _) | reraise (int major) | reraise (int minor)
    _ = raise "Only Scala 2.X.Y accepted, got '{str}'"

global data ScalaCrossVersion =
  Constant
  Major
  Minor

# TODO additional resolvers/repositories
# Should the cross versions be factored out?
tuple IvyDep =
  global Org:          String
  global Name:         String
  global Rev:          String
  global CrossVersion: ScalaCrossVersion

# TODO should this exist?
tuple UnexpandedIvyDep =
  global Dep:          IvyDep
  global CrossVersion: ScalaCrossVersion


# rename stringToIvyDep
global def stringToIvyDep string =
  match (tokenize ':' string)
    org, name, rev, Nil         = IvyDep org name rev Constant
    org, "", name, rev, Nil     = IvyDep org name rev Major
    org, "", "", name, rev, Nil = IvyDep org name rev Minor
    _                           = raise "Malformed Ivy Dep '{string}'"

global def ivyDepToString dep = match dep
  IvyDep org name rev cross = match cross
    Constant = "{org}:{name}:{rev}"
    Major    = "{org}::{name}:{rev}"
    Minor    = "{org}:::{name}:{rev}"

global def expandIvyDep version dep = match dep
  IvyDep org name rev cross = match cross
    Constant = dep
    Major    = IvyDep org "{name}_{scalaVersionMajorString version}" rev Constant
    Minor    = IvyDep org "{name}_{scalaVersionToString version}" rev Constant

global def isIvyDepExpanded dep = match dep.getIvyDepCrossVersion
  Constant = True
  _        = False

global def scalaCompilerIvyDep version =
  IvyDep "org.scala-lang" "scala-compiler" (scalaVersionToString version) Constant
global def scalaLibraryIvyDep version =
  IvyDep "org.scala-lang" "scala-library" (scalaVersionToString version) Constant

tuple ScalaModule =
  global Name:               String
  global RootDir:            String
  global ScalaVersion:       ScalaVersion
  global IvyDeps:            List IvyDep
  global Deps:               List ScalaModule
  # These are relative to RootDir
  global SourceDirs:         List String
  global ResourceDirs:       List String
  # These operations could be expensive
  global FnGeneratedSources: Unit => List Path
  global ScalacOptions:      List String
  global CompilerPlugins:    List IvyDep

def addSBTDefaults module =
  def sourceDirs = "src/main/scala", "src/main/java", _
  def resourceDirs = "src/main/resources", _
  module
  | editScalaModuleSourceDirs sourceDirs
  | editScalaModuleResourceDirs resourceDirs

global def makeScalaModule name dir version =
  ScalaModule name dir version Nil Nil Nil Nil (\_ Nil) Nil Nil
  | addSBTDefaults

global def makeScalaModuleFromJSON dir name =
  def json = readIvyDepsJSON dir
  def scalaVersion =
    json // name // "scalaVersion"
    | getJString
    | getOrElse (raise "scalaVersion not found!")
    | stringToScalaVersion
  def ivyDeps =
    json // name // "dependencies"
    | getJArray
    | getOrElse Nil
    | mapPartial getJString
    | map stringToIvyDep
  makeScalaModule name dir scalaVersion
  | setScalaModuleIvyDeps ivyDeps

def compareScalaModules a b =
  a.getScalaModuleName <=>* b.getScalaModuleName

def memoizeGenSrcs name module = memoize 1 (
  module.getScalaModuleFnGeneratedSources Unit
)
global def getScalaModuleGeneratedSources module =
  memoizeGenSrcs module.getScalaModuleName module

# WHy is this global? Make Expanded instead of Resolved
def getScalaModuleExpandedSourceDirs module =
  def mroot = module.getScalaModuleRootDir
  map (simplify "{mroot}/{_}") module.getScalaModuleSourceDirs

def getScalaModuleExpandedResourceDirs module =
  def mroot = module.getScalaModuleRootDir
  map (simplify "{mroot}/{_}") module.getScalaModuleResourceDirs

global def getScalaModuleTransDeps module =
  def folder tree mod =
    foldl helper tree mod.getScalaModuleDeps
  def helper tree mod = match (mod ∈ tree)
    True = tree
    False = folder (tinsert mod tree) mod
  def tree = folder (tnew compareScalaModules) module
  if module ∈ tree then raise "ScalaModule '{module.getScalaModuleName}' depends on itself!"
  else tree | treeToList

def flip f a b = f b a

# Excludes Scala itself
# Does not run expand ivy dependencies, nor does it invoke coursier
# TODO Make helper that takes an accumulator tree and checks if already present, returns if so, otherwise continues
global def getScalaModuleTransIvyDeps module =
  def allMods = module, module.getScalaModuleTransDeps
  def tree = tnew (_.ivyDepToString <=>* _.ivyDepToString)
  map getScalaModuleIvyDeps allMods
  | flatten
  | foldl tinsert.flip tree
  | treeToList

# Prefix with wildcard for the workspace
def inws path = "$WORKSPACE/{path}"

# TODO implement scalacOptions
def bloopScalaLibJSON scalaVersion scalacOptions =
  def ivyDep = scalaCompilerIvyDep scalaVersion
  def ivyJars = resolveIvyDeps (ivyDep, Nil)
  def jars = ivyJars | map getPathName | map inws | map JString | JArray
  JObject (
    "organization" → JString ivyDep.getIvyDepOrg,
    "name"         → JString ivyDep.getIvyDepName,
    "version"      → JString ivyDep.getIvyDepRev,
    "options"      → scalacOptions | map JString | JArray,
    "jars"         → jars,
    "setup" → JObject (
      "order" → JString "mixed",
      "addLibraryToBootClasspath" → JBoolean True,
      "addCompilerToClasspath" → JBoolean False,
      "addExtraJarsToClasspath" → JBoolean False,
      "manageBootClasspath" → JBoolean True,
      "filterLibraryFromClasspath" → JBoolean True,
      Nil
    ),
    Nil
  )

def buildDir module =
  def suffix = module.getScalaModuleScalaVersion.scalaVersionMajorString
  "{buildRoot.getPathName}/{module.getScalaModuleName}/scala-{suffix}"
def bloopOutDir module = "{bloopDir.getPathName}/{module.getScalaModuleName}"
def moduleClassesDir module = "{module.buildDir}/classes"

def bloopScalaModuleJSON module = match module
  ScalaModule name dir ver _ modDeps _ _ _ _ plugins =
    def bloopVersion = "1.2.5"
    def myDir = bloopOutDir module
    def ivyDeps = module.getScalaModuleTransIvyDeps
    def deps = map (expandIvyDep ver) ivyDeps
    def scalaLib = scalaLibraryIvyDep ver
    def ivyClasspath = resolveIvyDeps (scalaLib, deps) | map getPathName
    def transDeps = module.getScalaModuleTransDeps
    def depClasspath = transDeps | map moduleClassesDir
    def genSrcs = module.getScalaModuleGeneratedSources
    def sources = module.getScalaModuleExpandedSourceDirs ++ (map getPathName genSrcs)
    def resources = module.getScalaModuleExpandedResourceDirs
    def scalacOpts =
      def user = module.getScalaModuleScalacOptions
      def pluginOpts =
        def getPluginPath dep = expandIvyDep ver dep | getIvyDepJar | getPathName | inws
        plugins | map getPluginPath | map ("-Xplugin:{_}")
      user ++ pluginOpts
    JObject (
      "version" → JString bloopVersion,
      "project" → JObject (
        "name" → JString name,
        "directory" → JString dir.inws,
        "sources" → sources | map inws | map JString | JArray,
        "dependencies" → map getScalaModuleName modDeps | map JString | JArray,
        "classpath" → ivyClasspath ++ depClasspath | map inws | map JString | JArray,
        "out" → module.bloopOutDir.inws | JString,
        "classesDir" → module.moduleClassesDir.inws | JString,
        "resources" → resources | map inws | map JString | JArray,
        "scala" → bloopScalaLibJSON ver scalacOpts,
        Nil
      ),
      Nil
    )

# TODO is this necessary anymore?
def memoizeBloopTemplate name module = memoize 1 (
  def content = bloopScalaModuleJSON module | prettyJSON
  write (bloopTemplateName module) content
)
def bloopTemplate module =
  memoizeBloopTemplate module.getScalaModuleName module

def bloopTemplateName module =
  def name = module.getScalaModuleName
  "{bloopDir.getPathName}/{name}.json.template"

def bloopConfigName module =
  def name = module.getScalaModuleName
  "{bloopDir.getPathName}/{name}.json"

# Compiles a ScalaModule, returns bloop config and generated jar file
def memoizeBloopCompile name module = memoize 1 (
  def statedir = mkdir module.bloopOutDir
  def bin = bloopWake
  def transDeps = module.getScalaModuleTransDeps
  def configTemplate = module.bloopTemplate
  def configFilename = module.bloopConfigName
  def jarDir = mkdir "{module.buildDir}/jar"
  def jarName = "{jarDir.getPathName}/{name}.jar"
  def inputs =
    def sourceFiles =
      def dirs = module.getScalaModuleExpandedSourceDirs
      def auto = map (sources _ '.*\.(scala|java)') dirs | flatten
      def resources = map (sources _ '.*') module.getScalaModuleExpandedResourceDirs | flatten
      def unmanaged = module.getScalaModuleGeneratedSources
      unmanaged ++ resources ++ auto
    def depJars = map compileScalaModule transDeps
    def configs = map bloopConfig transDeps
    def timeout = sources here "bloop_timeout" | head
    bin, timeout, bloopWake, configTemplate, configs ++ depJars ++ sourceFiles
  def bloopArgs =
    def args = "compile", "-c", bloopDir.getPathName, module.getScalaModuleName, Nil
    args | catWith " "
  def cmd =
    bin.getPathName, "-t", configTemplate.getPathName, "-c", configFilename
    , "-b", bloopInstall, "--bloop-args", bloopArgs, "--jar", jarName, Nil
  def fnoutputs _ = configFilename, jarName, Nil
  def plan =
    makeManualPlan cmd inputs fnoutputs
    | setPlanFnInputs (\_ inputs | map getPathName)
    | runJob
  def outputs = plan.getJobOutputs
  def findjson = outputs | filter (matches configFilename _.getPathName)
  def findjar = outputs | filter (matches jarName _.getPathName)
  match findjson findjar
    (json, Nil) (jar, Nil) = Pair json jar
    _ _ = raise "Expected exactly one json and one jar, got {format outputs}"
)
def bloopCompile module = memoizeBloopCompile module.getScalaModuleName module

def bloopConfig module = bloopCompile module | getPairFirst

global def compileScalaModule module = bloopCompile module | getPairSecond

# Returns the full classpath to run the module
global def scalaModuleClasspath module =
  def version = module.getScalaModuleScalaVersion
  def scalaIvyDep = scalaCompilerIvyDep version
  def ivyJars =
    def ivyDeps = (scalaIvyDep, module.getScalaModuleTransIvyDeps) | map (expandIvyDep version)
    resolveIvyDeps ivyDeps
  def moduleJars = (module, module.getScalaModuleTransDeps) | map compileScalaModule
  moduleJars ++ ivyJars
