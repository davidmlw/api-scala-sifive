
# Important directories
def root = mkdir "build/{here}"
def bloopDir = mkdir "{root.getPathName}/bloop"
def bloopInstall = mkdir "scala"
def ivyCache = mkdir "ivycache"

# Make a virtual job that has the ivyCache files as outputs
# It's kind of a stand in for wit
# Virtual job
# virtual runner, keep false, fnoutputs are ivycache files
def ivyCacheDeps _ =
  def fs = files ivyCache.getPathName '.*'
  makePlan ("<ivycache>", ivyCache.getPathName, Nil) Nil
  | setPlanRunner    virtualRunner
  | setPlanKeep      False
  | setPlanFnOutputs (\_ fs)
  | runJob
  | getJobOutputs

global def readIvyDeps dir =
  def fn = "ivydependencies.json"
  def file = match (sources dir fn)
    one, Nil = one
    Nil      = raise "No {fn} found in {dir}!"
    multi    = raise "Multiple {fn} found: {format multi}"
  def json = parseJSONFile file.getPathName
  def version = match (json // "scalaVersion")
    JArray (JString str, Nil) = makeScalaVersion str
    JArray multi = raise "Multiple Scala versions found in {format file}!"
    _            = raise "Scala version not found in {format file}!"
  def extract = match _
    JString h, t = h, extract t
    Nil          = Nil
    x            = raise "Unexpected non-String dependency {format x}"
  def deps = match (json // "dependencies")
    JArray l = extract l
    x        = raise "Unexpected non-array dependencies {format x}"
  def ivyDeps = map (makeScalaIvyDep version _) deps
  Pair version ivyDeps

# Should be installed by wit
def coursierBin =
  def bins = files bloopInstall.getPathName '.*coursier.*'
  def bin = bins | head | makeStatePath
  try (\_ raise "coursier not found!") bin

# TODO Do this right
# This should be installed by wit
def bloopBin = makeStatePath "{bloopInstall.getPathName}/bloop"

# TODO kind of ugly
def bloopExe _ =
  def launcher = sources here "bloop_server" | head
  def timeout = sources here "bloop_timeout" | head
  def common = sources here "common.py" | head
  def pidfile = files here '.*\.pid' | head | makeStatePath
  def other = files bloopInstall.getPathName '.*'
  def cmd = launcher.getPathName, Nil
  #def visible = pidfile, launcher, timeout, common, (map makeStatePath other)
  def visible = launcher, timeout, common, (map makeStatePath other)
  def doit =
    makeManualPlan cmd visible (\_ Nil)
    | setPlanKeep False # Always rerun to make sure we have a running bloop server
    | runJob
  if doit.getJobStatus == 0 then bloopBin else raise "Error! Unable to launch bloop!"

# TODO
# - Rename?
# - Can we make this a fuse job? For some reason coursier can't find visible inputs
# Given List IvyDep, returns List String
# Return is paths to jars of the input IvyDeps and their transitive dependencies
global def coursierFetch deps =
  def depStrs = map getIvyDepString deps
  def cachedDeps = ivyCacheDeps Unit
  def cmd = coursierBin.getPathName, "fetch", "-q", "--cache", ivyCache.getPathName, "-m", "offline", depStrs
  #def cmd = coursierBin.getPathName, "fetch", "-q", "--cache", ivyCache.getPathName, depStrs
  def plan = makeManualPlan cmd (coursierBin, cachedDeps) (\_ Nil)
  #def plan = makePlan cmd (coursierBin, cachedDeps)
  def job = plan.runJob
  if job.getJobStatus == 0 then
    def strs = job.getJobStdout | tokenize '\n' | filter (_ !=~ "")
    def tree = ltree scmpRaw strs
    filter (_.getPathName âˆˆ tree) cachedDeps
  else raise "Cannot resolve ivy dependencies, have you run `wit update` (currently unimplemented)?"

# TODO improve
global def runIvyDep dep = runJava (coursierFetch (dep, Nil))

# TODO improve
# - Customize java installation
# - Add Java options (eg. -Xmx4G)
# visible excludes classpath
global def runJava classpath main args visible =
  def java = which "java"
  def cp = "-cp", (map getPathName classpath | catWith ":"), Nil
  def cmd = java, cp ++ (main, args)
  job cmd (visible ++ classpath)

# TODO Dotty support?
tuple ScalaVersion =
  global Major Integer
  global Minor Integer

def scalaVersionToString = match _
  ScalaVersion major minor = "2.{str(major)}.{str(minor)}"

global def makeScalaVersion str =
  def err = raise "Only Scala 2.X.Y accepted, got '{str}'"
  match (tokenize '\.' str)
    majormajor, major, minor, Nil =
      if majormajor ==~ "2" then ScalaVersion (int major) (int minor) else err
    _ = err

# TODO additional resolvers/repositories
tuple IvyDep =
  global Org String
  global Name String
  global Rev String

global def makeScalaIvyDep scalaVersion string =
  def err = raise "Malformed Scala Ivy Dep '{string}'"
  match (tokenize ':' string)
    org, name, rev, Nil = IvyDep org name rev
    org, blank, name, rev, Nil =
      def namex = "{name}_2.{str(scalaVersion.getScalaVersionMajor)}"
      if "{blank}x" ==~ "x" then IvyDep org namex rev else err
    _ = err

global def makeJavaIvyDep string =
  match (tokenize ':' string)
    org, name, rev, Nil = IvyDep org name rev
    _ = raise "Malformed Java Ivy Dep '{string}'"

global def getIvyDepString = match _
  IvyDep org name rev = "{org}:{name}:{rev}"

global def scalaCompilerIvyDep version =
  IvyDep "org.scala-lang" "scala-compiler" (scalaVersionToString version)
global def scalaLibraryIvyDep version =
  IvyDep "org.scala-lang" "scala-library" (scalaVersionToString version)

tuple ScalaModule =
  global Name             String
  global RootDir          String
  global ScalaVersion     ScalaVersion
  global IvyDeps          List IvyDep
  global Deps             List ScalaModule
  SourceDirs_             List String
  ResourceDirs            List String
  global GeneratedSources List Path

global def getScalaModuleSourceDirs = match _
  ScalaModule _ dir _ _ _ sourceDirs _ _ =
    map ("{dir}/{_}") sourceDirs

def genSourceDir name = mkdir "{root.getPathName}/generated-src"

global def getScalaModuleGeneratedSourceDir = match _
  ScalaModule name _ _ _ _ _ _ _ = genSourceDir name

# Should the source dirs be relative to root or incldue it?
global def makeSBTScalaModule name dir version =
  def scalaVersion = makeScalaVersion version
  def sourceDirs =
    "src/main/scala", "src/main/java", Nil | map ("{dir}/{_}")
  def resourceDirs = "{dir}/src/main/resources", Nil
  ScalaModule name dir scalaVersion Nil Nil sourceDirs resourceDirs Nil

# TODO implement scalacOptions
def bloopScalaLibJSON scalaVersion =
  def ivyDep = scalaCompilerIvyDep scalaVersion
  def org = Pair "organization" (JString ivyDep.getIvyDepOrg)
  def name = Pair "name" (JString ivyDep.getIvyDepName)
  def version = Pair "version" (JString ivyDep.getIvyDepRev)
  def options = Pair "options" (JArray Nil)
  def jars = Pair "jars" $ coursierFetch (ivyDep, Nil) | map getPathName | map JString | JArray
  def setup =
    def fields =
      Pair "order" (JString "mixed")
      , Pair "addLibraryToBootClasspath" (JBoolean True)
      , Pair "addCompilerToClasspath" (JBoolean False)
      , Pair "addExtraJarsToClasspath" (JBoolean False)
      , Pair "manageBootClasspath" (JBoolean True)
      , Pair "filterLibraryFromClasspath" (JBoolean True)
      , Nil
    Pair "setup" (JObject fields)
  JObject (org, name, version, options, jars, setup, Nil)

#def buildDir module = "{root.getPathName}/{module.getScalaModuleName}"
def bloopOutDir module = "{bloopDir.getPathName}/{module.getScalaModuleName}"
def bloopClassesDir module = "{root.getPathName}/{module.getScalaModuleName}/classes"

# TODO
# - implement module dependencies (see jdeps)
def bloopScalaModuleJSON scalaModule =
  def bloopVersion = "1.2.5"
  def project = match scalaModule
    ScalaModule name dir version ivyDeps modDeps sourceDirs resourceDirs genSrcs =
      def myDir = bloopOutDir scalaModule
      def scalaLib = scalaLibraryIvyDep version
      def ivyClasspath = (scalaLib, ivyDeps) | coursierFetch | map getPathName
      def depClasspath = modDeps | map bloopClassesDir
      def sources = (map ("{dir}/{_}") sourceDirs) ++ (map getPathName genSrcs)
      def fields =
        Pair   "name" (JString name)
        , Pair "directory" (JString dir)
        , Pair "sources" (JArray (map JString sources))
        , Pair "dependencies" (JArray (map getScalaModuleName modDeps | map JString))
        , Pair "classpath" (ivyClasspath ++ depClasspath | map JString | JArray)
        , Pair "out" (bloopOutDir scalaModule | JString)
        , Pair "classesDir" (bloopClassesDir scalaModule | JString)
        , Pair "scala" (bloopScalaLibJSON version)
        , Nil
      #JObject (jname, jdir, jsources, jdeps, jcp, jout, jclasses, jscala, Nil)
      JObject fields
  def bloop = Pair "version" (JString bloopVersion)
  def proj = Pair "project" project
  JObject (bloop, proj, Nil)

def bloopConfig module = memoize 0 (
  def content = bloopScalaModuleJSON module | prettyJSON
  write (bloopConfigName module) content
)

def bloopConfigName module =
  def name = module.getScalaModuleName
  "{bloopDir.getPathName}/{name}.json"

# TODO
# - Include ivy and transitive ivy deps in visible files
# - Include Bloop configs and build dirs for dependencies
# - Use local bloop
global def compileScalaModule  module =
  def config = module.bloopConfig
  def outdir = mkdir module.bloopClassesDir
  def statedir = mkdir module.bloopOutDir
  def bin = bloopExe Unit
  def modDeps = module.getScalaModuleDeps
  def allInputs =
    def sourceFiles =
      def dirs = module.getScalaModuleSourceDirs
      map (sources _ '.*\.(scala|java)') dirs | flatten
    def depClassFiles =
      map compileScalaModule modDeps | flatten
    sourceFiles ++ depClassFiles
  def depConfigFiles =
    map bloopConfig modDeps
  def cmd = bin.getPathName, "compile", "-c", bloopDir.getPathName, module.getScalaModuleName, Nil
  def visible = (bin, config, outdir, statedir, depConfigFiles)
  def plan =
    makePlan cmd visible
    | setPlanFnOutputs (\_ files outdir.getPathName '.*\.class')
    | setPlanFnInputs (\_ allInputs | map getPathName)
  plan.runJob.getJobOutputs

