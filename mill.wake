
global def millBin _ =
  def version = "0.3.5"
  def dir = mkdir (simplify "{here}/bin")
  def getter = sources here 'getMill\.sh' | head
  def cmd = (getter.getPathName, version, Nil)
  def doit = job cmd (getter, dir, Nil)
  doit.getJobOutput

# Base mill project for generated project to extend
# trait to extend, .sc file to import
data MillBaseProject = MillBaseProject String String

data ScalaProject =
  ScalaProject String Path (List ScalaProject) (Option MillBaseProject)

# name, root directory, Scala project dependencies
global def simpleScalaProject name root deps = ScalaProject name root deps None

# name, root directory, Scala project dependencies, mill file to import, mill trait to extend
global def millScalaProject name root deps mfile mtrait =
  ScalaProject name (mkdir root) deps (Some (MillBaseProject mfile mtrait))

global def scalaProjectName = match _
  ScalaProject name _ _ _ = name

global def scalaProjectDir = match _
  ScalaProject _ dir _ _ = dir

#global def scalaSources proj = sources (scalaProjectDir proj) ".*\.sc(ala)?"
global def scalaSources proj = files "." '.*\.sc'

global def millBuild name =
  def a = "// This file was generated by wake, do not modify!", b
  def b = "import mill._, scalalib._\n", c
  def c = "object {name} extends ScalaModule \{", d
  def d = " def scalaVersion = \"2.12.4\"", e
  def e = "\}\n", Nil
  catWith "\n" a

# Generates the text for a mill module from a ScalaModule
def generateMillModule = match _
  ScalaProject name dirPath deps mill =
    def dir = dirPath.getPathName
    def millSourcePath = match mill
      None = "  override def millSourcePath = os.pwd / RelPath(\"{dir}\") / \"{name}\""
      Some _ =
        "  override def millSourcePath = os.pwd / RelPath(\"{dir}\") / super.millSourcePath.relativeTo(os.pwd)"
    def a =
      def base = "object {name} extends ScalaModule"
      def res = match mill
        None = "{base} \{", Nil
        Some (MillBaseProject file trait) =
          def bb = "{name}BaseBuild"
          def path = catWith "." $ map (\x "`{x}`") $ tokenize "/" dir
          "import $file.{path}.\{`{file}` => {bb}\}", "{base} with {bb}.{trait} \{", Nil
      res ++ b
    def b = "  def scalaVersion = \"2.12.4\"", c
    def c = millSourcePath, d
    def d =
      def body = catWith ", " (map scalaProjectName deps)
      if matches "" body
      then e
      else
        def x = "  def wakeModuleDeps = Seq({body})"
        "{x}\n  def moduleDeps = super.moduleDeps ++ wakeModuleDeps", e
    def e = "\}\n", Nil
    catWith "\n" a

def millFilePrefix =
  def a = "// This file was generated by wake, do not modify!", b
  def b = "import mill._, scalalib._", c
  def c = "import ammonite.ops._\n", Nil
  catWith "\n" a

def allScalaProjects =
  subscribe scalaProjects
  | distinctBy depsComp

def depsComp proj1 proj2 =
  scmpNFKC proj1.scalaProjectName proj2.scalaProjectName
# This generates a top-level mill file if there are Scala projects present
# This also gets all dependencies from the internet, the generated build.sc is used as a stand-in
#   for other tasks to depend on
# TODO
#  * Make more efficient by using ROOT of dependency tree(s)
global def millFile proj = memoize 0 (
  match (proj, allScalaProjects)
    Nil = None
    projects =
      def modules = map generateMillModule projects
      def content = (catWith "\n" (millFilePrefix, modules))
      def filename = simplify "./build.sc"
      write filename content | Some
)

global def ivyCache = simplify "{here}/.coursier"
global def millCache = simplify "{here}/.mill"
publish environment = "COURSIER_CACHE={ivyCache}", Nil

def millBaseCmd _ = (millBin Unit).getPathName, "-i", "--home", millCache, Nil

global def scalaProjectAssembly proj =
  def job = millTask proj "assembly" Nil
  def name = scalaProjectName proj
  def jar =
    def regex = simplify "./out/{name}/assembly/dest/out.jar"
    find (matches regex _.getPathName) job.getJobOutputs
  match jar
    None = raise "Error during assembly"
    Some (Pair f _) = f

# Invoke mill directly
# TODO What do we do about having to hash all of the ivy cache and files in out?
global def millTask proj task args =
  def mill = millBin Unit
  def buildFile = match proj.millFile
    Some f = f
    None = raise "Cannot run millTask if there are no scala projects!"
  def outDir = simplify "./out/{project}/{task}"
  def inputs =
    def everything = (sources "." '.*\.scala')# ++ (files "." '.*\.sc')
    # Uniqufiy the dirs so that we don't get duplicate files
    # Lie about inputs, hashing too many files is slow so until that's faster, don't hash caches
    mill, buildFile, everything
  # FIXME hashing is still slow, only have jars at outputs
  def outputs _ = files outDir '.*jar'
  def project = proj.scalaProjectName
  def dir = proj.scalaProjectDir
  def cmd = (mill.getPathName, "-i", "--home", millCache, "show", "{project}.{task}", Nil) ++ args
  def doit = manualJob cmd inputs outputs
  doit

