
global def millBin _ =
  def version = "0.3.5"
  def dir = mkdir 0775 (simplify "{here}/bin")
  def getter = "{here}/getMill.sh"
  def cmd = (getter, version, Nil)
  def doit = job cmd (getter, dir, Nil)
  doit.output

# Base mill project for generated project to extend
# trait to extend, .sc file to import
data MillBaseProject = MillBaseProject String String

data ScalaProject =
  ScalaProject String String (List ScalaProject) (Option MillBaseProject)

# name, root directory, Scala project dependencies
global def simpleScalaProject name root deps = ScalaProject name root deps None

# name, root directory, Scala project dependencies, mill file to import, mill trait to extend
global def millScalaProject name root deps mfile mtrait =
  ScalaProject name root deps (Some (MillBaseProject mfile mtrait))

global def scalaProjectName = match _
  ScalaProject name _ _ _ = name

global def scalaProjectDir = match _
  ScalaProject _ dir _ _ = dir

#global def scalaSources proj = sources (scalaProjectDir proj) ".*\.sc(ala)?"
global def scalaSources proj = files "." '.*\.sc'

global def millBuild name =
  def a = "// This file was generated by wake, do not modify!", b
  def b = "import mill._, scalalib._\n", c
  def c = "object {name} extends ScalaModule \{", d
  def d = " def scalaVersion = \"2.12.4\"", e
  def e = "\}\n", Nil
  catWith "\n" a

# Generates the text for a mill module from a ScalaModule
def generateMillModule = match _
  ScalaProject name dir deps mill =
    def millSourcePath = match mill
      None = "  override def millSourcePath = os.pwd / RelPath(\"{dir}\") / \"{name}\""
      Some _ =
        "  override def millSourcePath = os.pwd / RelPath(\"{dir}\") / super.millSourcePath.relativeTo(os.pwd)"
    def a =
      def base = "object {name} extends ScalaModule"
      def res = match mill
        None = "{base} \{", Nil
        Some (MillBaseProject file trait) =
          def bb = "{name}BaseBuild"
          def path = catWith "." $ map (\x "`{x}`") $ tokenize "/" dir
          "import $file.{path}.\{`{file}` => {bb}\}", "{base} with {bb}.{trait} \{", Nil
      res ++ b
    def b = "  def scalaVersion = \"2.12.4\"", c
    def c = millSourcePath, d
    def d =
      def body = catWith ", " (map scalaProjectName deps)
      if matches "" body
      then e
      else
        def x = "  def wakeModuleDeps = Seq({body})"
        "{x}\n  def moduleDeps = super.moduleDeps ++ wakeModuleDeps", e
    def e = "\}\n", Nil
    catWith "\n" a

def millFilePrefix =
  def a = "// This file was generated by wake, do not modify!", b
  def b = "import mill._, scalalib._", c
  def c = "import ammonite.ops._\n", Nil
  catWith "\n" a

def allScalaProjects = subscribe scalaProjects ++ (subscribe scalaProjectLists).flatten
# This generates a top-level mill file if there are Scala projects present
# This also gets all dependencies from the internet, the generated build.sc is used as a stand-in
#   for other tasks to depend on
# TODO
#  * Make more efficient by using ROOT of dependency tree(s)
global def millFile _ = match allScalaProjects
  Nil = None
  projects =
    def modules = map generateMillModule projects
    def content = (catWith "\n" (millFilePrefix, modules))
    def filename = simplify "./build.sc"
    waitOne (\_ Some filename) (write 0664 filename content)

global def ivyCache = simplify "{here}/.coursier"
global def millCache = simplify "{here}/.mill"
publish environment = "COURSIER_CACHE={ivyCache}"

def millBaseCmd _ = (millBin ""), "-i", "--home", millCache, Nil

global def scalaProjectAssembly proj =
  def job = millTask proj "assembly" Nil
  def name = scalaProjectName proj
  def jar =
    def regex = simplify "./out/{name}/assembly/dest/out.jar"
    find (matches regex _.first) job.outputs
  match jar
    None = raise "Error during assembly"
    Some (Pair f _) = f.first

# Invoke mill directly
# TODO What do we do about having to hash all of the ivy cache and files in out?
global def millTask proj task args =
  def mill = millBin ""
  def buildFile = match (millFile "")
    Some f = f
    None = raise "Cannot run millTask if there are no scala projects!"
  def outDir = simplify "./out"
  def inputs =
    # Uniqufiy the dirs so that we don't get duplicate files
    def unique dirs = distinctBy (_ ==^ _) (sortBy (_ <^ _) dirs)
    def projDirs = unique (map scalaProjectDir allScalaProjects)
    # Lie about inputs, hashing too many files is slow so until that's faster, don't hash caches
    # def allDirs = ivyCache, millCache, outDir, projDirs
    def allDirs = projDirs
    mill, buildFile, (map (files _ '.*') allDirs).flatten
  # FIXME hashing is still slow, only have jars at outputs
  def outputs _ = files outDir '.*jar'
  def project = proj.scalaProjectName
  def dir = proj.scalaProjectDir
  def cmd = (mill, "-i", "--home", millCache, "show", "{project}.{task}", Nil) ++ args
  def doit = cached_manual_job "." "" environment cmd inputs outputs
  doit

